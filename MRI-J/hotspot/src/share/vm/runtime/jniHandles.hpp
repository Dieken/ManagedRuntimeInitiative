/*
 * Copyright 1998-2007 Sun Microsystems, Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
 *  
 */
// This file is a derivative work resulting from (and including) modifications
// made by Azul Systems, Inc.  The date of such changes is 2010.
// Copyright 2010 Azul Systems, Inc.  All Rights Reserved.
//
// Please contact Azul Systems, Inc., 1600 Plymouth Street, Mountain View, 
// CA 94043 USA, or visit www.azulsystems.com if you need additional information 
// or have any questions.
#ifndef JNIHANDLES_HPP
#define JNIHANDLES_HPP

#include "allocation.hpp"
#include "gpgc_collector.hpp"
#include "ostream.hpp"
#include "virtualspace.hpp"

class BoolObjectClosure;
class BoolObjectRefClosure;
class JNIHandleBlock;
class OopClosure;

// Interface for creating and resolving local/global JNI handles

class JNIHandles : AllStatic {
 public:
  enum Constants {
    // Used to distinguish JNI weak global refs from other JNI handles.  Note:
    // The proxy makes use of the 0x1 and 0x2 bits in handles generated by the
    // JVM, so those bits are off limits.
    JNIWeakHandleTag = 0x4
  };

 private:
  static JNIHandleBlock* _global_handles;             // First global handle block
  static JNIHandleBlock* _weak_global_handles;        // First weak global handle block
  static objectRef _deleted_handle;                   // Sentinel marking deleted handles
  
  static bool thread_is_locked();  // For debugging, ensure thread holds JVM lock

 public:
  // Resolve handle into oop
  inline static oop resolve(jobject handle);
  // Resolve externally provided handle into oop with some guards
  inline static oop resolve_external_guard(jobject handle);
  // Resolve handle into oop, result guaranteed not to be null
  inline static oop resolve_non_null(jobject handle);

  // Resolve handle into ref
inline static objectRef resolve_as_ref(jobject handle);
  // Resolve handle into ref, skip the assertions
inline static objectRef resolve_as_ref_external_guard(jobject handle);
  // Resolve handle into ref, result guaranteed non-null
inline static objectRef resolve_as_non_null_ref(jobject handle);

  // Resolve non-null weak handle into ref, result may be null
  static objectRef resolve_non_null_weak(jobject handle);

  // Local handles
  static jobject make_local(objectRef obj);
  static jobject make_local(JNIEnv* env, objectRef obj);    // Fast version when env is known
  static jobject make_local(Thread* thread, objectRef obj); // Even faster version when current thread is known
  inline static void destroy_local(jobject handle);

  // Global handles
  static jobject make_global(Handle  obj);
  static void destroy_global(jobject handle);
  static bool      is_global_handles(JNIHandleBlock *jhb) { return jhb ==      _global_handles; }
  static bool is_weak_global_handles(JNIHandleBlock *jhb) { return jhb == _weak_global_handles; }

  // Weak global handles
  static jobject make_weak_global(Handle obj);
  static void destroy_weak_global(jobject handle);

  // jmethodID handling (as Weak global handles).
  // Because the useful life-span of a jmethodID cannot be determined, once created they are
  // never reclaimed.  The methods to which they refer, however, can be GC'ed away if the class
  // is unloaded or if the method is made obsolete or deleted -- in these cases, the jmethodID 
  // refers to NULL (as is the case for any weak reference).
  static jmethodID make_jmethod_id(methodHandle mh);
  static void destroy_jmethod_id(jmethodID mid);
  inline static bool is_method(klassOop koop, jmethodID mid);
  inline static methodRef resolve_jmethod_id(jmethodID mid);
  inline static methodRef checked_resolve_jmethod_id(jmethodID mid); // NULL on invalid jmethodID
  static void change_method_associated_with_jmethod_id(jmethodID jmid, methodHandle mh);

  // Sentinel marking deleted handles in block. Note that we cannot store NULL as 
  // the sentinel, since clearing weak global JNI refs are done by storing NULL in
  // the handle. The handle may not be reused before destroy_weak_global is called.
  static objectRef deleted_handle()  { return _deleted_handle; }

  // Initialization
  static void initialize();
  
  // Debugging
  static void print_on(outputStream* st);
  static void print()		{ print_on(tty); }
  static void verify();
  static bool is_local_handle(Thread* thread, jobject handle);
  static bool is_frame_handle(JavaThread* thr, jobject obj);
  static bool is_global_handle(jobject handle);
  static bool is_weak_global_handle(jobject handle);
  static long global_handle_memory_usage();
  static long weak_global_handle_memory_usage();

  // Garbage collection support(global handles only, local handles are traversed from thread)
  // Traversal of regular global handles
  static void oops_do(OopClosure* f);
  // Traversal of weak global handles. Unreachable oops are cleared.
  static void weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f);
static void weak_oops_do(BoolObjectRefClosure*is_alive,OopClosure*f);
  static void GPGC_weak_oops_do(bool is_new_gc);
};



// JNI handle blocks holding local/global JNI handles

class JNIHandleBlock : public CHeapObj {
 private:
  enum SomeConstants {     
    block_size_in_oops  = 32                    // Number of handles per handle block
  };

  objectRef       _handles[block_size_in_oops]; // The handles
  int             _top;                         // Index of next unused handle
  JNIHandleBlock* _next;                        // Link to next block

  // The following instance variables are only used by the first block in a chain. 
  // Having two types of blocks complicates the code and the space overhead in negligble.
  JNIHandleBlock* _last;                        // Last block in use 
  JNIHandleBlock* _pop_frame_link;              // Block to restore on PopLocalFrame call
intptr_t*_free_list;//Handle free list
  int             _allocate_before_rebuild;     // Number of blocks to allocate before rebuilding free list

  JNIHandleBlock* _block_list_link;             // Link for list below
  static JNIHandleBlock* _block_list;           // List of all allocated blocks (for debugging only)

  static JNIHandleBlock* _block_free_list;      // Free list of currently unused blocks
  static int      _blocks_allocated;            // For debugging/printing

  static VirtualSpace _vs;                      // Commits virtual memory for allocating handles
  static char *_curaddr;                        // Tracks current memory space

  // Fill block with bad_handle values
  void zap();

  // No more handles in the both the current and following blocks
  void clear() { _top = 0; }

  // Free list computation
  void rebuild_free_list();

 public:
  // Handle allocation
  jobject allocate_handle(objectRef obj);

  // Block allocation and block free list management
  static JNIHandleBlock* allocate_block(Thread* thread = NULL);
  static void release_block(JNIHandleBlock* block, Thread* thread = NULL);

  // JNI PushLocalFrame/PopLocalFrame support
  JNIHandleBlock* pop_frame_link() const          { return _pop_frame_link; }
  void set_pop_frame_link(JNIHandleBlock* block)  { _pop_frame_link = block; }

  int capacity() const                            { return block_size_in_oops - _top; }

  // Stub generator support
  static int top_offset_in_bytes()                { return offset_of(JNIHandleBlock, _top); }

  // Garbage collection support
  // Traversal of regular handles
  void oops_do(OopClosure* f);
  // Traversal of weak handles. Unreachable oops are cleared.
  void weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f);
void weak_oops_do(BoolObjectRefClosure*is_alive,OopClosure*f);
  void GPGC_weak_oops_do(bool is_new_gc);

  static char *jnihandle_base()                 { return _vs.low_boundary(); }
  static char *jnihandle_top()                  { return _vs.high_boundary(); }
  static void initialize();                     // In order to initialize the memor allocation
  static JNIHandleBlock *allocate_blockarea();  // Allocates a new JNIHandleBlock from committed memory
  // This giant area is so we can convert JNI handles to a 32 bit index for 32-bit proxies.
  static const size_t JNIHANDLE_AREA_ALIGNMENT = (2048 * (size_t)M);
  static const size_t JNIHANDLE_AREA_SIZE = (2048 * (size_t)M);

  // Debugging
  bool chain_contains(jobject handle) const;    // Does this block or following blocks contain handle
  bool contains(jobject handle) const;          // Does this block contain handle
  int length() const;                           // Length of chain starting with this block
  long memory_usage() const;
  static bool any_contains(jobject handle);     // Does any block currently in use contain handle
#ifndef PRODUCT
  static void print_statistics();
#endif
};


inline oop JNIHandles::resolve(jobject handle) {
assert(thread_is_locked(),"Can't work on object in heap without holding the JVM lock");
oop result;
if(handle==NULL){
result=NULL;
  }
  else if (uint64_t(handle) & JNIWeakHandleTag) {
    handle = jobject(uint64_t(handle) ^ JNIWeakHandleTag);
assert(UseGenPauselessGC,"Tagged JNI weak ref without UseGenPauselessGC");
assert(!CheckJNICalls||is_weak_global_handle(handle),"JNI weak handle not in weak global handle block");
    assert(*((uint64_t*)handle) != badJNIHandleVal, "Pointing to zapped jni handle area");
    result = GPGC_Collector::JNI_weak_reference_resolve((objectRef*)handle).as_oop();
  }
  else {
    assert (*((uint64_t*)handle) != badJNIHandleVal, "Pointing to zapped jni handle area");
    result = lvb_ref((objectRef*)handle).as_oop();
    assert(result != NULL || (handle == NULL || !CheckJNICalls || is_weak_global_handle(handle)), "Invalid value read from jni handle");
  }
  return result;
}


inline oop JNIHandles::resolve_external_guard(jobject handle) {
assert(thread_is_locked(),"Can't work on object in heap without holding the JVM lock");
oop result;
if(handle==NULL){
result=NULL;
  }
  else if (intptr_t(handle) & JNIWeakHandleTag) {
    handle = jobject(intptr_t(handle) ^ JNIWeakHandleTag);
assert(UseGenPauselessGC,"Tagged JNI weak ref without UseGenPauselessGC");
assert(!CheckJNICalls||is_weak_global_handle(handle),"JNI weak handle not in weak global handle block");
    uint64_t rawRef = *((uint64_t*)handle);
    if (rawRef == 0 || rawRef == badJNIHandleVal) { return NULL; }
    result = GPGC_Collector::JNI_weak_reference_resolve((objectRef*)handle).as_oop();
  }
  else {
    uint64_t rawRef = *((uint64_t*)handle);
    if (rawRef == 0 || rawRef == badJNIHandleVal) { return NULL; }
    result = lvb_ref((objectRef*)handle).as_oop();
  }
  return result;
}


inline oop JNIHandles::resolve_non_null(jobject handle) {
assert(thread_is_locked(),"Can't work on object in heap without holding the JVM lock");
  assert(handle != NULL, "JNI handle should not be null");
objectRef r;
  if (intptr_t(handle) & JNIWeakHandleTag) {
    // TODO does it really make sense to allow weak JNI refs in this resolve method?
    handle = jobject(uint64_t(handle) ^ JNIWeakHandleTag);
assert(UseGenPauselessGC,"Tagged JNI weak ref without UseGenPauselessGC");
assert(!CheckJNICalls||is_weak_global_handle(handle),"JNI weak handle not in weak global handle block");
    assert(*((uint64_t*)handle) != badJNIHandleVal, "Pointing to zapped jni handle area");
    r = GPGC_Collector::JNI_weak_reference_resolve((objectRef*)handle);
assert(r.not_null(),"Invalid value read from weak jni handle");
  }
  else {
    uint64_t rawRef = *((uint64_t*)handle);
assert(rawRef!=0,"Invalid value read from jni handle");
    assert(rawRef != badJNIHandleVal, "Pointing to zapped jni handle area");
    r = lvb_ref((objectRef*)handle);
  }
  oop result = r.as_oop();
  // Don't let that private _deleted_handle object escape into the wild.
assert(r!=deleted_handle(),"Used a deleted global handle.");
  return result;
}

// Method validity check.
inline bool JNIHandles::is_method(klassOop koop, jmethodID jmid) {
  methodOop moop = checked_resolve_jmethod_id(jmid).as_methodOop();
if(moop==NULL){
    return false; 
  }
if(koop==NULL){
    return true;  
  }
  if (!Klass::cast(koop)->is_subtype_of(moop->method_holder())) { 
    return false; 
  }
  return true;
}

inline methodRef JNIHandles::resolve_jmethod_id(jmethodID mid) {
  return methodRef(resolve_as_non_null_ref((jobject)mid).raw_value());
};
  
inline methodRef JNIHandles::checked_resolve_jmethod_id(jmethodID mid) {
  jobject handle = (jobject)mid;
  if (is_weak_global_handle(handle)) {
    return methodRef(resolve_as_non_null_ref(handle).raw_value());
  } else {
return methodRef((uint64_t)0);
  }
};


inline objectRef JNIHandles::resolve_as_ref(jobject handle){
assert(thread_is_locked(),"Can't work on object in heap without holding the JVM lock");
objectRef result;
if(handle==NULL){
result=nullRef;
  }
  else if (intptr_t(handle) & JNIWeakHandleTag) {
    handle = jobject(uint64_t(handle) ^ JNIWeakHandleTag);
assert(UseGenPauselessGC,"Tagged JNI weak ref without UseGenPauselessGC");
assert(!CheckJNICalls||is_weak_global_handle(handle),"JNI weak handle not in weak global handle block");
    result = GPGC_Collector::JNI_weak_reference_resolve((objectRef*)handle);
  }
  else {
    result = lvb_ref((objectRef*)handle);
assert(result.not_null(),"Invalid value read from jni handle");
  }
  return result;
}

inline objectRef JNIHandles::resolve_as_ref_external_guard(jobject handle){
assert(thread_is_locked(),"Can't work on object in heap without holding the JVM lock");
objectRef result;
if(handle==NULL){
result=nullRef;
  }
  else if (intptr_t(handle) & JNIWeakHandleTag) {
    handle = jobject(uint64_t(handle) ^ JNIWeakHandleTag);
assert(UseGenPauselessGC,"Tagged JNI weak ref without UseGenPauselessGC");
assert(!CheckJNICalls||is_weak_global_handle(handle),"JNI weak handle not in weak global handle block");
    result = GPGC_Collector::JNI_weak_reference_resolve((objectRef*)handle);
  }
  else {
    result = lvb_ref((objectRef*)handle);
  }
  return result;
}

inline objectRef JNIHandles::resolve_as_non_null_ref(jobject handle){
assert(thread_is_locked(),"Can't work on object in heap without holding the JVM lock");
assert(handle!=NULL,"JNI handle should not be null");
  objectRef result;
  if (intptr_t(handle) & JNIWeakHandleTag) {
    handle = jobject(uint64_t(handle) ^ JNIWeakHandleTag);
assert(UseGenPauselessGC,"Tagged JNI weak ref without UseGenPauselessGC");
assert(!CheckJNICalls||is_weak_global_handle(handle),"JNI weak handle not in weak global handle block");
    result = GPGC_Collector::JNI_weak_reference_resolve((objectRef*)handle);
assert(result.not_null(),"Invalid value read from jni handle");
assert(result!=deleted_handle(),"Used a deleted global handle");
  }
  else {
    result = lvb_ref((objectRef*)handle);
assert(result.not_null(),"Invalid value read from jni handle");
assert(result!=deleted_handle(),"Used a deleted global handle");
  }
  return result;
}

inline void JNIHandles::destroy_local(jobject handle) {
  if (handle != NULL) {
#ifdef ASSERT
Thread*thr=Thread::current();
if(thr->is_Java_thread()){
JavaThread*jthr=(JavaThread*)thr;
      if (is_frame_handle(jthr, handle)) {
        // stack values can't be poisoned, we won't recycle this handle
        *((objectRef*)handle) = ALWAYS_UNPOISON_OBJECTREF(deleted_handle());
      } else {
        assert(is_local_handle(jthr, handle), "must be in thread local handles block");
*((objectRef*)handle)=deleted_handle();//allocate will recycle
      }
    } else {
      // a compiler or other such thread with a handlerized objectRef
      assert(is_local_handle(thr, handle), "must be in thread local handles block");
*((objectRef*)handle)=deleted_handle();//allocate will recycle
    }
#else
    // Production code: ALWAYS_UNPOISON_OBJECTREF(deleted_handle) == deleted_handle
    *((objectRef*)handle) = deleted_handle();
#endif
  }
}
#endif // JNIHANDLES_HPP
